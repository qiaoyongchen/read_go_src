qiaoyongchen@hotmail.com

go1.17

先明确几个概念:

- 1.反射是检查存储在接口变量中的类型和值的算法
- 2.接口也是一种类型，其内存保存了 < 实际对象值，实际对象类型，[约束的方法集] >
- 3.reflect.TypeOf 和 reflect.ValueOf 都是针对空接口(interface{}) 做解析
- 4.Type()可以区分实际类型，Kind()只可以区分底层类型 

反射包实现了运行时的反射，允许程序在运行时操控任意类型的对象。通常用法是，通过获取将一个值转为静态类型 interface{} 使用 reflect.TypeOf 解析出运行时的动态类型。

调用 ValueOf 返回一个表示运行时的数据的 值。

```go
// Type 是一个接口，是go类型的表示形式

// 不是所有的方法都能用于所有类型，如果可能的话，文档中会标明
// 对于类型敏感的方法，在使用前通过Kind方法找出静态类型的底层类型
// 对用静态类型的底层类型使用了错误的方法将导致运行时 panic

// Type 的值时可比较的，可以使用 == 操作符，所以可以作为 map 的key
type Type interface {
    // 以下这些方法包含了所有类型的方法
    
    // Align 返回 当该类型被分配内存后，一个该类型的值，对齐的字节数
	Align() int
    
    // FieldAlign 返回当该类型作为结构体字段时，对齐的字节数
	FieldAlign() int
    
    // Method 返回 该类型方法集中第i个方法
    // 对于非接口类型：返回的 Method 的 Type 和 Func 字段描述了接受者作为第一个参数的函数
    // 对于接口类型: 返回的 Method 的 Type 字段给出方法签名，并且没有接收者，并且其 Func 字段为 nil(接口的方法没有实际值)
    // 多个方法之间按字典序排序
	Method(int) Method
	
    // MethodByName 返回一个名字在方法集中的方法 和 一个是否找到的标识
    // 对于非接口类型的值 T 或者 *T, 返回的 Method 的 Type 和 Func 描述第一个参数作为接受者的 function
    // 对于接口类型: 返回的 Method 的 Type 字段给出方法签名，并且没有接收者，并且其 Func 字段为 nil(接口的方法没有实际值)
    MethodByName(string) (Method, bool)
    
    // NumMethod 返回在使用 Method 时可访问的方法数量
    // NumMethod 值统计接口类型的非导出方法
	NumMethod() int
    
    // Name 返回包括 package 名字的 type 的名字
	Name() string
    
    // PkgPath 返回已定义过的 type 的 包路径，也就是说，导入路径唯一标识这个 package
    // 如果 type 是预定义的(string, error)或者未定义的(*T, struct{},
	// []int, A - A 是一个未定义 type 的别名)， PkgPath 返回空字符串
	PkgPath() string
    
    // Size 返回该 type 的 value 在被存储的时候需要的字节数，和 unsafe.Sizeof 一样
	Size() uintptr
    
    // String 返回该 type 的字符串表示
    // 可能使用 短包名 （比如 用 base64 代替 "encoding/base64"）
    // 这种表示法不保证唯一性
    // 如果需要比较 type 的表示，直接比较 type 就行了（前面说过可以直接比较 用 ==）
	String() string
    
    // Kind 返回 该 type 的底层类型
	Kind() Kind
    
    // Implements 报告是否该 type 实现了接口类型 u.
	Implements(u Type) bool
    
    // AssignableTo 报告该类型值是否可以赋值给 Type u
	AssignableTo(u Type) bool
    
    // ConvertibleTo 报告该 类型的值能否转换为 Type u
	ConvertibleTo(u Type) bool
    
    // Comparable 报告该类型的值之间是否可以直接比较
	Comparable() bool
    
    // 以上的方法 所有 类型都可以使用
    // 一下的方法只有特定的类型才能使用，具体依赖底层类型
    // 每种底层类型(kind)可被使用的方法为:
    //	Int*, Uint*, Float*, Complex*: Bits
	//	Array: Elem, Len
	//	Chan: ChanDir, Elem
	//	Func: In, NumIn, Out, NumOut, IsVariadic.
	//	Map: Key, Elem
	//	Ptr: Elem
	//	Slice: Elem
	//	Struct: Field, FieldByIndex, FieldByName, FieldByNameFunc, NumField
    
    // Bits 表示 该类型的 size 占用位数
    // 如果底层类型不是 Int*, Uint*, Float*, Complex* 就报异常
	Bits() int
    
    // ChanDir returns 管道类型的方向 (<-chan int 出方向 , chan<- int 进方向)
	ChanDir() ChanDir
    
    // IsVariadic 报告 函数类型的最后一个参数是否为 ... 形式
    // 如果是 ... 形式，那么 t.IN(t.NumIn() - 1) 返回的实际是 []T
    // func(x int, y ... float64)
    // t.NumIn() == 2
	// t.In(0) is the reflect.Type for "int"
	// t.In(1) is the reflect.Type for "[]float64"
	// t.IsVariadic() == true
	//  如果 type 的底层类型不是 Func 报异常
    IsVariadic() bool
    
    // Elem 返回该类型指向的元素的类型 
    // 底层类型需要为 Array, Chan, Map, Ptr, or Slice
	Elem() Type
    
    // Field 返回 struct 的第 i 个字段
    // 底层类型需要为 struct 
    // i 超过 字段数区间 则报错
	Field(i int) StructField
    
    // FieldByIndex 用一个 int 序列查找嵌套的字段
    // 底层类型需要为 struct
	FieldByIndex(index []int) StructField
	
    // 通过 name 匹配 field 返回 StructField
    // 需要为 struct
    FieldByName(name string) (StructField, bool)
	
    // 通过字段名匹配函数找出 StructField
    FieldByNameFunc(match func(string) bool) (StructField, bool)
	In(i int) Type
	Key() Type
	Len() int
	NumField() int
	NumIn() int
	NumOut() int
	Out(i int) Type

	common() *rtype
	uncommon() *uncommonType
}
```

