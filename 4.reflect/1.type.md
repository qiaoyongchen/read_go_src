qiaoyongchen@hotmail.com

go1.17

先明确几个概念:

- 1.反射是检查存储在接口变量中的类型和值的算法
- 2.接口也是一种类型，其内存保存了 < 实际对象值，实际对象类型，[约束的方法集] >
- 3.reflect.TypeOf 和 reflect.ValueOf 都是针对空接口(interface{}) 做解析
- 4.Type()可以区分实际类型，Kind()只可以区分底层类型 

反射包实现了运行时的反射，允许程序在运行时操控任意类型的对象。通常用法是，通过获取将一个值转为静态类型 interface{} 使用 reflect.TypeOf 解析出运行时的动态类型。

调用 ValueOf 返回一个表示运行时的数据的 值。

```go
// Type 是一个接口，是go类型的表示形式

// 不是所有的方法都能用于所有类型，如果可能的话，文档中会标明
// 对于类型敏感的方法，在使用前通过Kind方法找出静态类型的底层类型
// 对用静态类型的底层类型使用了错误的方法将导致运行时 panic

// Type 的值时可比较的，可以使用 == 操作符，所以可以作为 map 的key
type Type interface {
    // 以下这些方法包含了所有类型的方法
    
    // Align 返回 当该类型被分配内存后，一个该类型的值，对齐的字节数
	Align() int
    
    // FieldAlign 返回当该类型作为结构体字段时，对齐的字节数
	FieldAlign() int
    
    // Method 返回 该类型方法集中第i个方法
    // 对于非接口类型：返回的 Method 的 Type 和 Func 字段描述了接受者作为第一个参数的函数
    // 对于接口类型: 返回的 Method 的 Type 字段给出方法签名，并且没有接收者，并且其 Func 字段为 nil(接口的方法没有实际值)
    // 多个方法之间按字典序排序
	Method(int) Method
	
    // MethodByName 返回一个名字在方法集中的方法 和 一个是否找到的标识
    // 对于非接口类型的值 T 或者 *T, 返回的 Method 的 Type 和 Func 描述第一个参数作为接受者的 function
    // 对于接口类型: 返回的 Method 的 Type 字段给出方法签名，并且没有接收者，并且其 Func 字段为 nil(接口的方法没有实际值)
    MethodByName(string) (Method, bool)
    
    // NumMethod 返回在使用 Method 时可访问的方法数量
    // NumMethod 值统计接口类型的非导出方法
	NumMethod() int
    
    // Name 返回包括 package 名字的 type 的名字
	Name() string
    
    // PkgPath 返回已定义过的 type 的 包路径，也就是说，导入路径唯一标识这个 package
    // 如果 type 是预定义的(string, error)或者未定义的(*T, struct{},
	// []int, A - A 是一个未定义 type 的别名)， PkgPath 返回空字符串
	PkgPath() string
    
    // Size 返回该 type 的 value 在被存储的时候需要的字节数，和 unsafe.Sizeof 一样
	Size() uintptr
    
    // String 返回该 type 的字符串表示
    // 可能使用 短包名 （比如 用 base64 代替 "encoding/base64"）
    // 这种表示法不保证唯一性
    // 如果需要比较 type 的表示，直接比较 type 就行了（前面说过可以直接比较 用 ==）
	String() string
    
    // Kind 返回 该 type 的底层类型
	Kind() Kind
    
    // Implements 报告是否该 type 实现了接口类型 u.
	Implements(u Type) bool
    
    // AssignableTo 报告该类型值是否可以赋值给 Type u
	AssignableTo(u Type) bool
    
    // ConvertibleTo 报告该 类型的值能否转换为 Type u
	ConvertibleTo(u Type) bool
    
    // Comparable 报告该类型的值之间是否可以直接比较
	Comparable() bool
    
    // 以上的方法 所有 类型都可以使用
    // 一下的方法只有特定的类型才能使用，具体依赖底层类型
    // 每种底层类型(kind)可被使用的方法为:
    //	Int*, Uint*, Float*, Complex*: Bits
	//	Array: Elem, Len
	//	Chan: ChanDir, Elem
	//	Func: In, NumIn, Out, NumOut, IsVariadic.
	//	Map: Key, Elem
	//	Ptr: Elem
	//	Slice: Elem
	//	Struct: Field, FieldByIndex, FieldByName, FieldByNameFunc, NumField
    
    // Bits 表示 该类型的 size 占用位数
    // 如果底层类型不是 Int*, Uint*, Float*, Complex* 就报异常
	Bits() int
    
    // ChanDir returns 管道类型的方向 (<-chan int 出方向 , chan<- int 进方向)
	ChanDir() ChanDir
    
    // IsVariadic 报告 函数类型的最后一个参数是否为 ... 形式
    // 如果是 ... 形式，那么 t.IN(t.NumIn() - 1) 返回的实际是 []T
    // func(x int, y ... float64)
    // t.NumIn() == 2
	// t.In(0) is the reflect.Type for "int"
	// t.In(1) is the reflect.Type for "[]float64"
	// t.IsVariadic() == true
	//  如果 type 的底层类型不是 Func 报异常
    IsVariadic() bool
    
    // Elem 返回该类型指向的元素的类型 
    // 底层类型需要为 Array, Chan, Map, Ptr, or Slice
	Elem() Type
    
    // Field 返回 struct 的第 i 个字段
    // 底层类型需要为 struct 
    // i 超过 字段数区间 则报错
	Field(i int) StructField
    
    // FieldByIndex 用一个 int 序列查找嵌套的字段
    // 底层类型需要为 struct
	FieldByIndex(index []int) StructField
	
    // 通过 name 匹配 field 返回 StructField
    // 底层类型需要为 struct
    FieldByName(name string) (StructField, bool)
	
    // 通过字段名匹配函数找出 StructField
    FieldByNameFunc(match func(string) bool) (StructField, bool)
    
    // 返回函数类型的第 i 个输入参数的 type
    // 底层类型需要为 Func
	In(i int) Type
    
    // 返回 map 可行的 key 的类型
    // 底层类型需要为 Map
	Key() Type
    
    // 返回 Array 类型的长度 (注意：只有 array 的长度和类型相关  map slice 的类型和长度无关)
    // 需要底层类型为 Array
	Len() int
    
    // 返回 Strcut 类型的字段数
    // 底层类型需要为 Struct
	NumField() int
    
    // 返回 Func 类型的输入参数的数量
	NumIn() int
    
    // 返回 Func 类型输出参数的数量
	NumOut() int
    
    // 返回函数类型的第 i 个输出参数的 type
    // 底层类型需要为 Func
	Out(i int) Type

    // 后面会介绍
	common() *rtype
	uncommon() *uncommonType
}
```

对于这句话的解释，可以简单实验下:

```go
// MethodByName 返回一个名字在方法集中的方法 和 一个是否找到的标识
// 对于非接口类型的值 T 或者 *T, 返回的 Method 的 Type 和 Func 描述第一个参数作为接受者的 function
// 对于接口类型: 返回的 Method 的 Type 字段给出方法签名，并且没有接收者，并且其 Func 字段为 nil(接口的方法没有实际值)

type Person struct {}

func (*Person) Do() { fmt.Println("aaaaa") }

type Doer interface { Do() }

p := new(Person)
pt := reflect.TypeOf(p)
ptf := pt.Method(0)
fmt.Println(ptf) // {Do  func(*main.Person) <func(*main.Person) Value> 0}

doer := (*Doer)(&d)
doerv := reflect.ValueOf(doer)
doervt := doerv.Elem().Type()
doervtf := doervt.Method(0)
fmt.Println(doervtf) // {Do  func() <invalid Value> 0}
```

type 表示 静态类型，kind 表示底层类型：

```go
type AnotherInt int
// AnotherInt 的静态类型为 AnotherInt （除非显式转换 否则不能和 int 类型互相传递至）, 底层类型 为 int
```

```go
// Kind 表示特殊类型 （我称为底层类型）
// 0 为 非法的类型
type Kind uint

const (
	Invalid Kind = iota
	Bool
	Int
	Int8
	Int16
	Int32
	Int64
	Uint
	Uint8
	Uint16
	Uint32
	Uint64
	Uintptr
	Float32
	Float64
	Complex64
	Complex128
	Array
	Chan
	Func
	Interface
	Map
	Ptr
	Slice
	String
	Struct
	UnsafePointer
)
```



```go
// tflag 被 rtype 用来 表示紧接着 rtype 后面的内存有哪些额外的 type 信息可用
type tflag uint8

const (
    // tflagUncommon 表示在 struct 外，紧接着有一个 *uncommonType 的指针
    // 即:
    // 如果 t.Kind() == Struct and t.tflag&tflagUncommon != 0
    // 那么可以这样强制转换:
    //	type tUncommon struct {
	//		structType
	//		u uncommonType
	//	}
	//	u := &(*tUncommon)(unsafe.Pointer(t)).u
	tflagUncommon tflag = 1 << 0 // 1
	
    // tflagExtraStar 在 str 字段中存在一个 额外的 * 前缀.
    // 这是由于在程序中，对于大多数类型 T， 同样会存在 *T， 并且重用会节省大小
	tflagExtraStar tflag = 1 << 1 // 2

    // tflagNamed 代表 这个 type 有名字
	tflagNamed tflag = 1 << 2 // 4
	
    // tflagRegularMemory 表示 equal和hash函数可以将此类型视为t.size字节的区域
    // * 具体干嘛的不太清楚，之前看源码没注意
	tflagRegularMemory tflag = 1 << 3 // 8
)
```

对于 'tflagUncommon' 可以简单的验证下，因为 golang 的数据存储 按照字节对齐存储，所以理论上使用 unsafe 包找到起始地址，直接强制转换就可以:

```go
type A struct {
	B
	C string
}

type B struct {
	D string
}

var a = &A{ // *A
    B: B{
        D: "D",
    },
    C: "C",
}
var b = &a.B // *B

aa := (*A)(unsafe.Pointer(b)) // *B 直接 转换为 *A， 虽然 B 的静态类型中没有 C
fmt.Println(aa.B.D, aa.C) // D C
```





































