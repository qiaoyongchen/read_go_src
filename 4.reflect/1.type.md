qiaoyongchen@hotmail.com

go1.17

先明确几个概念:

- 1.反射是检查存储在接口变量中的类型和值的算法
- 2.接口也是一种类型，其内存保存了 < 实际对象值，实际对象类型，[约束的方法集] >
- 3.reflect.TypeOf 和 reflect.ValueOf 都是针对空接口(interface{}) 做解析
- 4.Type()可以区分实际类型，Kind()只可以区分底层类型 

反射包实现了运行时的反射，允许程序在运行时操控任意类型的对象。通常用法是，通过获取将一个值转为静态类型 interface{} 使用 reflect.TypeOf 解析出运行时的动态类型。

调用 ValueOf 返回一个表示运行时的数据的 值。

```go
// Type 是一个接口，是go类型的表示形式

// 不是所有的方法都能用于所有类型，如果可能的话，文档中会标明
// 对于类型敏感的方法，在使用前通过Kind方法找出静态类型的底层类型
// 对用静态类型的底层类型使用了错误的方法将导致运行时 panic

// Type 的值时可比较的，可以使用 == 操作符，所以可以作为 map 的key
type Type interface {
    // 以下这些方法包含了所有类型的方法
    
    // Align 返回 当该类型被分配内存后，一个该类型的值，对齐的字节数
	Align() int
    
    // FieldAlign 返回当该类型作为结构体字段时，对齐的字节数
	FieldAlign() int
    
    // Method 返回 该类型方法集中第i个方法
    // 对于非接口类型：返回的 Method 的 Type 和 Func 字段描述了接受者作为第一个参数的函数
    // 对于接口类型: 返回的 Method 的 Type 字段给出方法签名，并且没有接收者，并且其 Func 字段为 nil(接口的方法没有实际值)
    // 多个方法之间按字典序排序
	Method(int) Method
	
    MethodByName(string) (Method, bool)
	NumMethod() int
	Name() string
	PkgPath() string
	Size() uintptr
	String() string
	Kind() Kind
	Implements(u Type) bool
	AssignableTo(u Type) bool
	ConvertibleTo(u Type) bool
	Comparable() bool
	Bits() int
	ChanDir() ChanDir
	IsVariadic() bool
	Elem() Type
	Field(i int) StructField
	FieldByIndex(index []int) StructField
	FieldByName(name string) (StructField, bool)
	FieldByNameFunc(match func(string) bool) (StructField, bool)
	In(i int) Type
	Key() Type
	Len() int
	NumField() int
	NumIn() int
	NumOut() int
	Out(i int) Type

	common() *rtype
	uncommon() *uncommonType
}
```

