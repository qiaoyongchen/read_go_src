qiaoyongchen@hotmail.com

go1.17

先明确几个概念:

- 1.反射是检查存储在接口变量中的类型和值的算法
- 2.接口也是一种类型，其内存保存了 < 实际对象值，实际对象类型，[约束的方法集] >
- 3.reflect.TypeOf 和 reflect.ValueOf 都是针对空接口(interface{}) 做解析
- 4.Type()可以区分实际类型，Kind()只可以区分底层类型 

反射包实现了运行时的反射，允许程序在运行时操控任意类型的对象。通常用法是，通过获取将一个值转为静态类型 interface{} 使用 reflect.TypeOf 解析出运行时的动态类型。

调用 ValueOf 返回一个表示运行时的数据的 值。

```go
// Type 是一个接口，是go类型的表示形式

// 不是所有的方法都能用于所有类型，如果可能的话，文档中会标明
// 对于类型敏感的方法，在使用前通过Kind方法找出静态类型的底层类型
// 对用静态类型的底层类型使用了错误的方法将导致运行时 panic

// Type 的值时可比较的，可以使用 == 操作符，所以可以作为 map 的key
type Type interface {
    // 以下这些方法包含了所有类型的方法
    
    // Align 返回 当该类型被分配内存后，一个该类型的值，对齐的字节数
	Align() int
    
    // FieldAlign 返回当该类型作为结构体字段时，对齐的字节数
	FieldAlign() int
    
    // Method 返回 该类型方法集中第i个方法
    // 对于非接口类型：返回的 Method 的 Type 和 Func 字段描述了接受者作为第一个参数的函数
    // 对于接口类型: 返回的 Method 的 Type 字段给出方法签名，并且没有接收者，并且其 Func 字段为 nil(接口的方法没有实际值)
    // 多个方法之间按字典序排序
	Method(int) Method
	
    // MethodByName 返回一个名字在方法集中的方法 和 一个是否找到的标识
    // 对于非接口类型的值 T 或者 *T, 返回的 Method 的 Type 和 Func 描述第一个参数作为接受者的 function
    // 对于接口类型: 返回的 Method 的 Type 字段给出方法签名，并且没有接收者，并且其 Func 字段为 nil(接口的方法没有实际值)
    MethodByName(string) (Method, bool)
    
    // NumMethod 返回在使用 Method 时可访问的方法数量
    // NumMethod 值统计接口类型的非导出方法
	NumMethod() int
    
    // Name 返回包括 package 名字的 type 的名字
	Name() string
    
    // PkgPath 返回已定义过的 type 的 包路径，也就是说，导入路径唯一标识这个 package
    // 如果 type 是预定义的(string, error)或者未定义的(*T, struct{},
	// []int, A - A 是一个未定义 type 的别名)， PkgPath 返回空字符串
	PkgPath() string
    
    // Size 返回该 type 的 value 在被存储的时候需要的字节数，和 unsafe.Sizeof 一样
	Size() uintptr
    
    // String 返回该 type 的字符串表示
    // 可能使用 短包名 （比如 用 base64 代替 "encoding/base64"）
    // 这种表示法不保证唯一性
    // 如果需要比较 type 的表示，直接比较 type 就行了（前面说过可以直接比较 用 ==）
	String() string
    
    // Kind 返回 该 type 的底层类型
	Kind() Kind
    
    // Implements 报告是否该 type 实现了接口类型 u.
	Implements(u Type) bool
    
    // AssignableTo 报告该类型值是否可以赋值给 Type u
	AssignableTo(u Type) bool
    
    // ConvertibleTo 报告该 类型的值能否转换为 Type u
	ConvertibleTo(u Type) bool
    
    // Comparable 报告该类型的值之间是否可以直接比较
	Comparable() bool
    
    // 以上的方法 所有 类型都可以使用
    // 一下的方法只有特定的类型才能使用，具体依赖底层类型
    // 每种底层类型(kind)可被使用的方法为:
    //	Int*, Uint*, Float*, Complex*: Bits
	//	Array: Elem, Len
	//	Chan: ChanDir, Elem
	//	Func: In, NumIn, Out, NumOut, IsVariadic.
	//	Map: Key, Elem
	//	Ptr: Elem
	//	Slice: Elem
	//	Struct: Field, FieldByIndex, FieldByName, FieldByNameFunc, NumField
    
    // Bits 表示 该类型的 size 占用位数
    // 如果底层类型不是 Int*, Uint*, Float*, Complex* 就报异常
	Bits() int
    
    // ChanDir returns 管道类型的方向 (<-chan int 出方向 , chan<- int 进方向)
	ChanDir() ChanDir
    
    // IsVariadic 报告 函数类型的最后一个参数是否为 ... 形式
    // 如果是 ... 形式，那么 t.IN(t.NumIn() - 1) 返回的实际是 []T
    // func(x int, y ... float64)
    // t.NumIn() == 2
	// t.In(0) is the reflect.Type for "int"
	// t.In(1) is the reflect.Type for "[]float64"
	// t.IsVariadic() == true
	//  如果 type 的底层类型不是 Func 报异常
    IsVariadic() bool
    
    // Elem 返回该类型指向的元素的类型 
    // 底层类型需要为 Array, Chan, Map, Ptr, or Slice
	Elem() Type
    
    // Field 返回 struct 的第 i 个字段
    // 底层类型需要为 struct 
    // i 超过 字段数区间 则报错
	Field(i int) StructField
    
    // FieldByIndex 用一个 int 序列查找嵌套的字段
    // 底层类型需要为 struct
	FieldByIndex(index []int) StructField
	
    // 通过 name 匹配 field 返回 StructField
    // 底层类型需要为 struct
    FieldByName(name string) (StructField, bool)
	
    // 通过字段名匹配函数找出 StructField
    FieldByNameFunc(match func(string) bool) (StructField, bool)
    
    // 返回函数类型的第 i 个输入参数的 type
    // 底层类型需要为 Func
	In(i int) Type
    
    // 返回 map 可行的 key 的类型
    // 底层类型需要为 Map
	Key() Type
    
    // 返回 Array 类型的长度 (注意：只有 array 的长度和类型相关  map slice 的类型和长度无关)
    // 需要底层类型为 Array
	Len() int
    
    // 返回 Strcut 类型的字段数
    // 底层类型需要为 Struct
	NumField() int
    
    // 返回 Func 类型的输入参数的数量
	NumIn() int
    
    // 返回 Func 类型输出参数的数量
	NumOut() int
    
    // 返回函数类型的第 i 个输出参数的 type
    // 底层类型需要为 Func
	Out(i int) Type

    // 后面会介绍
	common() *rtype
	uncommon() *uncommonType
}
```

对于这句话的解释，可以简单实验下:

```go
// MethodByName 返回一个名字在方法集中的方法 和 一个是否找到的标识
// 对于非接口类型的值 T 或者 *T, 返回的 Method 的 Type 和 Func 描述第一个参数作为接受者的 function
// 对于接口类型: 返回的 Method 的 Type 字段给出方法签名，并且没有接收者，并且其 Func 字段为 nil(接口的方法没有实际值)

type Person struct {}

func (*Person) Do() { fmt.Println("aaaaa") }

type Doer interface { Do() }

p := new(Person)
pt := reflect.TypeOf(p)
ptf := pt.Method(0)
fmt.Println(ptf) // {Do  func(*main.Person) <func(*main.Person) Value> 0}

doer := (*Doer)(&d)
doerv := reflect.ValueOf(doer)
doervt := doerv.Elem().Type()
doervtf := doervt.Method(0)
fmt.Println(doervtf) // {Do  func() <invalid Value> 0}
```

type 表示 静态类型，kind 表示底层类型：

```go
type AnotherInt int
// AnotherInt 的静态类型为 AnotherInt （除非显式转换 否则不能和 int 类型互相传递至）, 底层类型 为 int
```

```go
// Kind 表示特殊类型 （我称为底层类型）
// 0 为 非法的类型
type Kind uint

const (
	Invalid Kind = iota
	Bool
	Int
	Int8
	Int16
	Int32
	Int64
	Uint
	Uint8
	Uint16
	Uint32
	Uint64
	Uintptr
	Float32
	Float64
	Complex64
	Complex128
	Array
	Chan
	Func
	Interface
	Map
	Ptr
	Slice
	String
	Struct
	UnsafePointer
)

var kindNames = []string{
	Invalid:       "invalid",
	Bool:          "bool",
	Int:           "int",
	Int8:          "int8",
	Int16:         "int16",
	Int32:         "int32",
	Int64:         "int64",
	Uint:          "uint",
	Uint8:         "uint8",
	Uint16:        "uint16",
	Uint32:        "uint32",
	Uint64:        "uint64",
	Uintptr:       "uintptr",
	Float32:       "float32",
	Float64:       "float64",
	Complex64:     "complex64",
	Complex128:    "complex128",
	Array:         "array",
	Chan:          "chan",
	Func:          "func",
	Interface:     "interface",
	Map:           "map",
	Ptr:           "ptr",
	Slice:         "slice",
	String:        "string",
	Struct:        "struct",
	UnsafePointer: "unsafe.Pointer",
}
```



```go
// tflag 被 rtype 用来 表示紧接着 rtype 后面的内存有哪些额外的 type 信息可用
type tflag uint8

const (
    // tflagUncommon 表示在 struct 外，紧接着有一个 *uncommonType 的指针
    // 即:
    // 如果 t.Kind() == Struct and t.tflag&tflagUncommon != 0
    // 那么可以这样强制转换:
    //	type tUncommon struct {
	//		structType
	//		u uncommonType
	//	}
	//	u := &(*tUncommon)(unsafe.Pointer(t)).u
	tflagUncommon tflag = 1 << 0 // 1
	
    // tflagExtraStar 在 str 字段中存在一个 额外的 * 前缀.
    // 这是由于在程序中，对于大多数类型 T， 同样会存在 *T， 并且重用会节省大小
	tflagExtraStar tflag = 1 << 1 // 2

    // tflagNamed 代表 这个 type 有名字
	tflagNamed tflag = 1 << 2 // 4
	
    // tflagRegularMemory 表示 equal 和hash 函数可以将此类型视为t.size字节的区域
    // * 具体干嘛的不太清楚，之前看源码没注意，可能就字面意思吧
	tflagRegularMemory tflag = 1 << 3 // 8
)
```

这几个标记按位标识，表示可能组合出现。对于 'tflagUncommon' 可以简单的验证下，因为 golang 的数据存储 按照字节对齐存储，所以理论上使用 unsafe 包找到起始地址，直接强制转换就可以:

```go
type A struct {
	B
	C string
}

type B struct {
	D string
}

var a = &A{ // *A
    B: B{
        D: "D",
    },
    C: "C",
}
var b = &a.B // *B

aa := (*A)(unsafe.Pointer(b)) // *B 直接 转换为 *A， 虽然 B 的静态类型中没有 C
fmt.Println(aa.B.D, aa.C) // D C
```

rtype reflect包中很重要的数据结构：

```go
// rtype 是大部分类型的通用实现
// 嵌入在其他 type 中
type rtype struct {
	size       uintptr // size
	ptrdata    uintptr // 表示可以包含指针的字节数
	hash       uint32  // type 的 hash
	tflag      tflag   // 额外 type 信息的标志（就是上面的 tflag）
	align      uint8   // 这个类型变量的字节对齐
	fieldAlign uint8   // 作为结构字段的字节对齐
	kind       uint8   // 底层类型
	// 用于比较这个类型对象的函数
	// (ptr to object A, ptr to object B) -> ==?
	equal     func(unsafe.Pointer, unsafe.Pointer) bool
	gcdata    *byte   // 垃圾收集数据
	str       nameOff // 字符串形式
	ptrToThis typeOff // 指向此类型的指针的类型
}

// func defined from line 685
```

上面一段代码中的 nameOff typeOff 是 int32 类型，代表偏移量，是如下定义的:

```go
type nameOff int32 // name 的偏移
type typeOff int32 // *rtype 的偏移量
type textOff int32 // 文本区域的偏移量

func (t *rtype) nameOff(off nameOff) name {
	return name{(*byte)(resolveNameOff(unsafe.Pointer(t), int32(off)))}
}

func (t *rtype) typeOff(off typeOff) *rtype {
	return (*rtype)(resolveTypeOff(unsafe.Pointer(t), int32(off)))
}

func (t *rtype) textOff(off textOff) unsafe.Pointer {
	return resolveTextOff(unsafe.Pointer(t), int32(off))
}

// resolveNameOff 表示基于一个基地址的偏移表示该 name 记录
// 这个基地址为 firstmoduledata.types
// firstmoduledata 是一个 moduledata 结构的示例，是一个链表，用 next 字段串起来
// 而 moduledata 表示二进制文件的布局信息，moduledata.types 记录的就是有关类型的信息
// resolveNameOff 是runtime包中实现，并且在编译时由 linker 写入的
// resolveNameOff 在runtime包中的实现简单描述为，从 firstmoduledata 中通过 next 逐个 查找
// ptrInModule + off 的地址，如果在某个 moduledata.types 和 moduledata.etypes 则算找到
// 返回 name , name 的结构为 type name struct { bytes *byte }
func resolveNameOff(ptrInModule unsafe.Pointer, off int32) unsafe.Pointer

// resolveTypeOff 与 resolveNameOff 类似，只是返回的是 *rtype
func resolveTypeOff(rtype unsafe.Pointer, off int32) unsafe.Pointer

// resolveTextOff 与 resolveNameOff 类似
func resolveTextOff(rtype unsafe.Pointer, off int32) unsafe.Pointer

// 换句话说 nameOff typeOff textOff 就是指向全局唯一的结构: firstmoduledata 的偏移地址
// 通过这个地址就能找到类型 name *rtype 的信息

// name 的结构为 
type name struct { 
    bytes *byte 
}

// 这些信息在后面顺序读源码读到的时候在介绍
```



```go
// 非接口类型的方法
type method struct {
	name nameOff // 方法名
	mtyp typeOff // 方法 type (无接收者)
	ifn  textOff // 用于作为接口调用时 (一个接收者)
	tfn  textOff // // 正常调用
}

// uncommonType 用于已定义的类型或者有方法的类型
// (如果T是定义的类型，则表示T和*T的uncommonTypes有方法).
// 这样做的目的是减少无方法的类型的描述
type uncommonType struct {
	pkgPath nameOff // package 地址
	mcount  uint16  // 方法数量
	xcount  uint16  // 可导出方法的数量
	moff    uint32  // 从 uncommontype 到 [mcount]method 的偏移
	_       uint32  // 未使用
}

func (t *uncommonType) methods() []method {
	if t.mcount == 0 {
		return nil
	}
	return (*[1 << 16]method)(add(unsafe.Pointer(t), uintptr(t.moff), "t.mcount > 0"))[:t.mcount:t.mcount]
}

func (t *uncommonType) exportedMethods() []method {
	if t.xcount == 0 {
		return nil
	}
	return (*[1 << 16]method)(add(unsafe.Pointer(t), uintptr(t.moff), "t.xcount > 0"))[:t.xcount:t.xcount]
}

// ChanDir 表示chan的方向
type ChanDir int

const (
	RecvDir ChanDir             = 1 << iota // <-chan
	SendDir                                 // chan<-
	BothDir = RecvDir | SendDir             // chan
)
```







































