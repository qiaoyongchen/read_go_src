qiaoyongchen@hotmail.com

go1.17

# 1.介绍

rpc 是 go 利用对外暴露的方法实现跨网络通信的一种方式。

一般我们这样使用：

```go
package main

import (
	"fmt"
	"log"
	"net"
	"net/rpc"
)

type Svc struct {} // 定义一个 service 

type Request struct { // 定义参数结构体
	A string
	B string
}

// 定义处理方法
func (svc *Svc) Conbine(r Request, rst *string) error {
	*rst = r.A + r.B
	return nil
}

func main() {
	// server
	svr := rpc.NewServer() // 一个 server
	svr.Register(&Svc{}) // 注册一个 service 
	lis, err := net.Listen("tcp", ":1234") // 监听一个地址
	if err != nil {
		log.Fatal("listen error", err)
	}
	go func() {
		for {
			conn, err := lis.Accept() // 接受一个链接
			if err != nil {
				log.Fatal("Accept error:", err)
			}
             go func() {
				svr.ServeConn(conn) // 链接交给 server处理
             }()
		}
    }()

	// client
	cli, err := rpc.Dial("tcp", ":1234") // 客户端拨号
	if err != nil {
		log.Fatal("dial error", err)
	}

	var rst string // 请求的结果放这里
	req := Request{ // 请求的参数结构体
		A: "A",
		B: "B",
	}
	cli.Call("Svc.Conbine", req, &rst) // 客户端请求
	fmt.Println(rst) // 打印结果
}
```

从上面可以看出，通过 ip 和 port 对外提供访问的成为server，提供具体访问的结构体成为 service，该 service 的方法称为 method。客户端可以通过 call("service.method", ...) 来请求具体的服务。另外，method 格式有一定要求，第一个参数为请求，第二个参数为结果（必须为指针，因为会被修改），并且返回 error。具体对应会在源码中清晰的看到。

# 2.源码

定义两个 http 方式请求的路径常量，没什么好解释的：

```go
const (
	// Defaults used by HandleHTTP
	DefaultRPCPath   = "/_goRPC_"
	DefaultDebugPath = "/debug/rpc"
)
```

定义一个 error 的反射类型，至于为什么这么设置，在读 error 包源码时，已经解释过：

```go
var typeOfError = reflect.TypeOf((*error)(nil)).Elem()
```

请求的方法，被定义为一个结构：

```go
type methodType struct {
	sync.Mutex // 互斥锁，用于在设置 numCalls 时提供保护
	method     reflect.Method // 方法类型的反射
    ArgType    reflect.Type // 方法参数的反射 （a.B(c, d int) 按照 go 的方法的定义，接受的是三个参数）
	ReplyType  reflect.Type // 方法的返回结果的反射
	numCalls   uint // 该方法的调用次数
}
```

请求的服务，被定义为一个结构：

```go
type service struct {
	name   string                 // 服务的名字
	rcvr   reflect.Value          // 服务的反射值
	typ    reflect.Type           // 服务的反射类型
	method map[string]*methodType // 一个服务可以有多个请求的方法
}
```

一次 rpc 请求，被定义为一个结构：

```go
type Request struct {
	ServiceMethod string   // 例子中 client 请求时的 "Svc.Conbine"
	Seq           uint64   // 请求序号
	next          *Request // 下一个空闲请求
}
```

空闲请求会被组成一个空闲 Request 列表，有一个 Server 维护。在并发的情况下，Seq 字段标识请求的唯一性，并在 response 中同样携带，以供 client 识别。

请求的响应，被定义为一个结构：

```go
type Response struct {
	ServiceMethod string    // 同请求
	Seq           uint64    // 同请求
	Error         string    // 返回的错误
	next          *Response // 下一个空闲的响应
}
```

一个 rpc server，被定义成一个结构：

```go
type Server struct {
	serviceMap sync.Map   // map[string]*service 一个 server 可以注册多个 service
	reqLock    sync.Mutex // 保护空闲请求列表的互斥锁
	freeReq    *Request // 空闲请求列表
	respLock   sync.Mutex // 保护空闲响应列表的互斥锁
	freeResp   *Response // 空闲的响应列表
}
```

从上面结构的联系可以看出结构的层次，一个 Server 可以包括多个 service，一个 service 包括多个 methodType。Server 内部维护两张空闲列表，方便重用。Server 列表的保护以及 methodType 对于 numCalls 的保护都提供了对应的互斥锁。

主要结构的层次，基本就上面几个，具体 rpc 内部如何运行，继续往下看。 

```go
func NewServer() *Server {
	return &Server{}
}

var DefaultServer = NewServer()
```

基本 new 操作，没什么好解释的。DefaultServer 用于包级别直接运行的默认实例，go 常用的方法，简化使用吧。

```go
// 判断类型是否时可导出类型或者内建类型
func isExportedOrBuiltinType(t reflect.Type) bool {
	for t.Kind() == reflect.Ptr {
		t = t.Elem()
	}
	return token.IsExported(t.Name()) || t.PkgPath() == ""
}
```

token.IsExported 就是判断是否时大写字母开头。

```go
// 注册 service
func (server *Server) Register(rcvr interface{}) error {
	return server.register(rcvr, "", false)
}
// 支持自定义 service 的名字
func (server *Server) RegisterName(name string, rcvr interface{}) error {
	return server.register(rcvr, name, true)
}
// 顶层的注册方法
// rcvr: service 可以时任何类型，所以是空接口
// name: 自定义的 service 名字
// useName: 是否使用自定义的 service 名字
func (server *Server) register(rcvr interface{}, name string, useName bool) error {
	// 创建 service，并通过反射获取字段需要的值
    s := new(service)
	s.typ = reflect.TypeOf(rcvr)
	s.rcvr = reflect.ValueOf(rcvr)
	sname := reflect.Indirect(s.rcvr).Type().Name()
	// 如果使用自提供的名字，则覆盖掉
    if useName {
		sname = name
	}
    // 不管怎么取，最终名字不能为空，否则直接报错退出
	if sname == "" {
		s := "rpc.Register: no service name for type " + s.typ.String()
		log.Print(s)
		return errors.New(s)
	}
    // service 必须是可到处类型
	if !token.IsExported(sname) && !useName {
		s := "rpc.Register: type " + sname + " is not exported"
		log.Print(s)
		return errors.New(s)
	}
	s.name = sname

	// 通过反射类型值，获取该 service 中合适的方法作为 method
    // 具体会在下面的源码中展开
	s.method = suitableMethods(s.typ, true)

    // 如果没有获取到哪怕一个合适的方法
	if len(s.method) == 0 {
		str := ""
		// go 开发人员还贴心的帮你用指针试一下
        // 如果还可以抢救一下的话，则提醒你一下（正巧，你看了报错的话）
		method := suitableMethods(reflect.PtrTo(s.typ), false)
		if len(method) != 0 {
			str = "rpc.Register: type " + sname + " has no exported methods of suitable type (hint: pass a pointer to value of that type)"
		} else {
			str = "rpc.Register: type " + sname + " has no exported methods of suitable type"
		}
		log.Print(str)
		return errors.New(str)
	}
	// 如果该名字已经被其他 servie 抢先注册了，那就不能用了，报错
	if _, dup := server.serviceMap.LoadOrStore(sname, s); dup {
		return errors.New("rpc: service already defined: " + sname)
	}
	return nil
}

// 通过反射类型找到合适做 methodType 的方法
func suitableMethods(typ reflect.Type, reportErr bool) map[string]*methodType {
	// 准备一个最终返回的 map 
    methods := make(map[string]*methodType)
    // 便利反射类型中的方法反射值
	for m := 0; m < typ.NumMethod(); m++ {
		method := typ.Method(m) // 第 m 个方法的反射值
		mtype := method.Type // 值类型
		mname := method.Name // 方法名
		if method.PkgPath != "" { // 不能是内建方法
			continue
		}
		// 如果方法传入参数不为3，就报错，这三个分别是：方法调用者，传入的请求，reply 的指针参数
		if mtype.NumIn() != 3 {
			if reportErr {
				log.Printf("rpc.Register: method %q has %d input parameters; needs exactly three\n", mname, mtype.NumIn())
			}
			continue
		}
		// 如果第二个参数不是可导出类型，或者是自建类型，则报错
		argType := mtype.In(1)
		if !isExportedOrBuiltinType(argType) {
			if reportErr {
				log.Printf("rpc.Register: argument type of method %q is not exported: %q\n", mname, argType)
			}
			continue
		}
		// 第三个参数必须是指针
		replyType := mtype.In(2)
		if replyType.Kind() != reflect.Ptr {
			if reportErr {
				log.Printf("rpc.Register: reply type of method %q is not a pointer: %q\n", mname, replyType)
			}
			continue
		}
		// 第三个参数必须可导出
		if !isExportedOrBuiltinType(replyType) {
			if reportErr {
				log.Printf("rpc.Register: reply type of method %q is not exported: %q\n", mname, replyType)
			}
			continue
		}
		// 返回参数必须为 1，并且是 error 类型
		if mtype.NumOut() != 1 {
			if reportErr {
				log.Printf("rpc.Register: method %q has %d output parameters; needs exactly one\n", mname, mtype.NumOut())
			}
			continue
		}
		if returnType := mtype.Out(0); returnType != typeOfError {
			if reportErr {
				log.Printf("rpc.Register: return type of method %q is %q, must be error\n", mname, returnType)
			}
			continue
		}
        // 符合条件的就加入
		methods[mname] = &methodType{method: method, ArgType: argType, ReplyType: replyType}
	}
	return methods
}
```

Server 注册 service 的流程，如果了解反射的话，很好理解。

















